
/**
 * @file firestore.rules
 * @description Security rules for the AgroCast Firestore database.
 *
 * @section Core Philosophy
 * This ruleset enforces a strict user-ownership model, ensuring that farmers have exclusive control over their personal and operational data. The security model is designed around the principle that a user (a "Farmer") can only access documents within their own data tree, which is segregated under the path `/users/{farmerId}`. Public data is world-readable, but write access is restricted.
 *
 * @section Data Structure
 * The data is organized into two main categories:
 * 1. User-Private Data: All data specific to a farmer, such as their profile, land details, profit predictions, risk forecasts, and harvest batches, is nested under `/users/{farmerId}`. Access to these paths is strictly controlled by matching the authenticated user's ID with the `{farmerId}` wildcard.
 * 2. Public & Shared Data: Collections that contain data relevant to all users, such as crop information (`/crops`) and marketplace listings (`/marketplace_offers`, `/buyers`, etc.), are placed at the root level. These collections are generally world-readable to facilitate app-wide features, but write access is tightly controlled.
 *
 * @section Key Security Decisions
 * - User Isolation: A user cannot read, list, or write data belonging to another user. This is the cornerstone of the security model.
 * - Public Read-Only Collections: Global data like `/crops`, `/buyers`, and `/suppliers` are publicly readable to all users (including unauthenticated ones) but are not writable by clients. This is a secure default for data that should be managed by a trusted backend or admin process.
 * - Owner-Controlled Public Content: For `/marketplace_offers`, documents are publicly readable, but only the farmer who created an offer can modify or delete it. Ownership is determined by a `farmerId` field denormalized onto each offer document.
 *
 * @section Denormalization for Authorization
 * To create simpler and more performant rules, this ruleset relies on denormalized data. Specifically, any document that needs ownership-based security outside of the `/users/{farmerId}` path (like a `MarketplaceOffer`) must contain a `farmerId` field. This avoids slow and costly `get()` calls to other documents during rule evaluation.
 *
 * @section Structural Segregation
 * The separation between private user subcollections (e.g., `/users/{farmerId}/lands`) and public top-level collections (e.g., `/marketplace_offers`) is intentional. This structure makes list operations both secure and efficient, preventing accidental exposure of private data in public queries.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // -------------------------------------------------------------------------
    // Helper Functions
    // -------------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for verifying document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Combines an ownership check with a check for the document's existence.
     * CRITICAL for all update and delete operations to prevent modifying non-existent data.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * Validates that the incoming document data contains a field that
     * correctly links it to a parent document in the path.
     * Used on CREATE to enforce relational integrity.
     */
    function incomingDataMatchesPath(fieldName, value) {
      return request.resource.data[fieldName] == value;
    }

    /**
     * Validates that a specific field in a document is immutable.
     * Used on UPDATE to prevent changing critical ownership or relational links.
     */
    function fieldIsImmutable(fieldName) {
      return request.resource.data[fieldName] == resource.data[fieldName];
    }


    // -------------------------------------------------------------------------
    // User-Private Collections
    // -------------------------------------------------------------------------

    /**
     * @description Manages farmer profile documents.
     * @path /users/{farmerId}
     * @allow A user creating their own profile: `auth.uid == 'farmer123'` (create) on `/users/farmer123`.
     * @deny An authenticated user trying to read another user's profile: `auth.uid == 'farmer456'` (get) on `/users/farmer123`.
     * @principle Restricts access to a user's own data tree and allows users to create their own root document.
     */
    match /users/{farmerId} {
      allow get, list, update, delete: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && incomingDataMatchesPath('id', farmerId);
    }

    /**
     * @description Manages land documents owned by a specific farmer.
     * @path /users/{farmerId}/lands/{landId}
     * @allow A farmer creating a land document under their own profile: `auth.uid == 'farmer123'` (create) on `/users/farmer123/lands/land_abc`.
     * @deny A farmer trying to delete another farmer's land: `auth.uid == 'farmer456'` (delete) on `/users/farmer123/lands/land_abc`.
     * @principle Enforces document ownership via path parameter and validates relational integrity on writes.
     */
    match /users/{farmerId}/lands/{landId} {
      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && incomingDataMatchesPath('farmerId', farmerId);
      allow update: if isExistingOwner(farmerId) && fieldIsImmutable('farmerId');
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages profit predictions for a specific piece of land.
     * @path /users/{farmerId}/lands/{landId}/profit_predictions/{profitPredictionId}
     * @allow A farmer reading a prediction for their own land: `auth.uid == 'farmer123'` (get) on a document in this path.
     * @deny Any user trying to list predictions for another farmer's land.
     * @principle Inherits ownership from the parent path (`farmerId`) and validates the link to the parent land document.
     */
    match /users/{farmerId}/lands/{landId}/profit_predictions/{profitPredictionId} {
      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && incomingDataMatchesPath('landId', landId);
      allow update: if isExistingOwner(farmerId) && fieldIsImmutable('landId');
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages climate risk forecasts for a specific piece of land.
     * @path /users/{farmerId}/lands/{landId}/climate_risk_forecasts/{climateRiskForecastId}
     * @allow A farmer creating a forecast for their own land: `auth.uid == 'farmer123'` (create) on a document in this path.
     * @deny Any user trying to update a forecast for another farmer's land.
     * @principle Inherits ownership from the parent path (`farmerId`) and validates the link to the parent land document.
     */
    match /users/{farmerId}/lands/{landId}/climate_risk_forecasts/{climateRiskForecastId} {
      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && incomingDataMatchesPath('landId', landId);
      allow update: if isExistingOwner(farmerId) && fieldIsImmutable('landId');
      allow delete: if isExistingOwner(farmerId);
    }

    /**
     * @description Manages harvest batches with blockchain traceability for a specific piece of land.
     * @path /users/{farmerId}/lands/{landId}/harvest_batches/{harvestBatchId}
     * @allow A farmer deleting a harvest batch from their own land: `auth.uid == 'farmer123'` (delete) on a document in this path.
     * @deny Any user trying to read harvest batches from another farmer's land.
     * @principle Inherits ownership from the parent path (`farmerId`) and validates the link to the parent land document.
     */
    match /users/{farmerId}/lands/{landId}/harvest_batches/{harvestBatchId} {
      allow get, list: if isOwner(farmerId);
      allow create: if isOwner(farmerId) && incomingDataMatchesPath('landId', landId);
      allow update: if isExistingOwner(farmerId) && fieldIsImmutable('landId');
      allow delete: if isExistingOwner(farmerId);
    }

    // -------------------------------------------------------------------------
    // Public & Shared Collections
    // -------------------------------------------------------------------------

    /**
     * @description Stores global crop information. Data is public and read-only for clients.
     * @path /crops/{cropId}
     * @allow Any user, authenticated or not, reading crop data: `auth == null` (get) on `/crops/wheat`.
     * @deny Any client trying to create, update, or delete a crop document.
     * @principle Provides public read access to global data while protecting it from client modification.
     */
    match /crops/{cropId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Manages marketplace offers, which are publicly viewable but can only be managed by their owner.
     * @path /marketplace_offers/{marketplaceOfferId}
     * @allow A farmer creating an offer and setting themselves as owner: `auth.uid == 'farmer123'` (create) with `request.resource.data.farmerId == 'farmer123'`.
     * @deny A farmer trying to delete another farmer's offer: `auth.uid == 'farmer456'` (delete) on an offer where `resource.data.farmerId == 'farmer123'`.
     * @principle Enforces document ownership for writes on a public collection, using a denormalized `farmerId` field.
     */
    match /marketplace_offers/{marketplaceOfferId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.farmerId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.farmerId) && fieldIsImmutable('farmerId');
      allow delete: if isExistingOwner(resource.data.farmerId);
    }

    /**
     * @description Stores public buyer profiles. Data is read-only for clients.
     * @path /buyers/{buyerId}
     * @allow Any user reading a buyer's profile: (get) on `/buyers/buyer_abc`.
     * @deny Any client trying to modify buyer data.
     * @principle Provides public read access to global data while protecting it from client modification.
     */
    match /buyers/{buyerId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores public supplier profiles. Data is read-only for clients.
     * @path /suppliers/{supplierId}
     * @allow Any user listing all suppliers: (list) on `/suppliers`.
     * @deny Any client trying to modify supplier data.
     * @principle Provides public read access to global data while protecting it from client modification.
     */
    match /suppliers/{supplierId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores public storage unit information. Data is read-only for clients.
     * @path /storage_units/{storageUnitId}
     * @allow Any user reading storage unit details: (get) on `/storage_units/unit_xyz`.
     * @deny Any client trying to modify storage unit data.
     * @principle Provides public read access to global data while protecting it from client modification.
     */
    match /storage_units/{storageUnitId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Stores public transport provider information. Data is read-only for clients.
     * @path /transport_providers/{transportProviderId}
     * @allow Any user listing all transport providers: (list) on `/transport_providers`.
     d     * @eny Any client trying to modify transport provider data.
     * @principle Provides public read access to global data while protecting it from client modification.
     */
    match /transport_providers/{transportProviderId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }
}
